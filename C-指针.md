## 变量
1. 不同类型的变量在内存中占据不同的字节空间
2. 内存中存储数据的最小基本单位是字节，每一个自己都有一个内存地址，这个地址是一个十六进制的数
3. 声明一个变量，在内存中是从高字节向低字节分配连续的指定字节数的空间
4. 任何数据在内存中都是以其二进制的补码形式存储的，低位存储在低字节，高位存储在高字节。
5. 变量的值：存储在变量中的数据，叫做变量的值
6. 变量的地址：一个变量是由一个或者多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址
7. 如何取出变量的地址  使用&（取地址运算符）运算符，&变量名；这个表达式的值就是这个变量的地址。使用%p控制度输出变量的地址 
8. 什么是指针：变量的地址叫做指针，指针就是地址，地址就是指针

 ## 指针

1. 指针是C语言的灵魂。

2. 变量在内存中的存储。  
   变量的值：存储在变量中的数据，叫做变量的值
   变量的地址：组成这个变量的低字节的地址，就是这个变量的地址
3. 取出变量的地址，用&运算符 %p输出变脸的地址
4. 什么是指针?
   变量的地址就叫做指针
   
###指针变量：

1. 指针变量就是专门用来存储地址的变量，那么我们就说指针变量指向了另外一个变量，用来存储另外一个变量的地址。
2. 只针的好处
   访问一个变量的方式主要分为两种。
   a. 直接访问
   b. 可以通过指针变量，找到这个指针指向的变量
   通过指针变量可以间接的访问指针变量指向的另外一个变量
3. 如何声明一个专门用来存储地址的指针变量
   数据类型 * 指针变量的名称 int* p1;
   指针变量的名字叫做p1，这个指针变量的类型是int* 读作int指针。
   * 表示，这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量，有哪些普通的类型 就可以有哪些指针的类型。
   声明的时候注意， * 的位置 建议  int* p
   一个指针变量并不是可以存储任意类型的变量的地址，而是有限定的，只能存储和这个指针类型相同的普通变量的地址。
   
   
4. 指针变量的初始化 
```
   int num = 10;
   int *p =  &num;
```
p指针指向了num变量。因为p指针的值就是num变量的地址

5. p指针自己也有地址， 因为指针变量也是一个变量，&p取到地址。
6. p操作的是p这个指针变量，可以取p得值，也可以为p赋值
   &p 拿到的是p的地址
7. 指针变量的使用
   可以使用指针间接的操作指针指向的变量。pointer指针
   *p 代表p指针指向的变量
   *p 完成等价于num 
   *p = 100;将100赋值给p指针指向的变量，也就是num变量
8. 野指针
  使用指针变量的时候注意点
  int *p1 ,p2, p3 p1指针，p2,p3int类型数据
  我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量中是有值的，垃圾值，随机数，这个时候，这个指针变量就有可能指向了一块随机的空间，这个空间可能无人使用，也可能别的程序在用，也可能系统在用，这个时候，去访问指针指向的的变量的时候，就会报错。BAD_ACCESS坏地址访问错误，像这样的指针我们就叫做也指针。  
 9. NULL值 
  为了防止野指针的产生，建议声明一个指针变量后，最好为其初始化，如果没有变量的地址初始化给这个指针变量。那你就初始化一个NULL值。NULL值代表指针变量不指向内存中的任何地址，谁都不指，这个NULL完全等价于0,所以也可以直接赋值给一个指针变量0
  如果一个指针变量的值是NULL，如果去访问这个指针指向的变量的时候一定会报错。
  
10. 多个指针指向同一个变量
11. 指针作为函数的参数
    如果函数的参数是一个指针，那么就必须要为这个指针传递一个和指针类型相同的普通变量的地址，这个时候，在函数的内部去访问参数指针的变量的时候，其实访问的就是实参变量
12. 指针作为函数的参数，可以实现什么效果？
    函数的内部可以修改实参变量的值。那么什么时候使用指针作为参数呢，一般函数只能返回一个数据，那么当函数需要返回多个数据的时候
可以使用指针作为参数，让调用者将自己的变量的地址传递给函数，函数将数值传回来。scanf 传递的就是指针
13. 指针为什么要分类型
    指针变量是一个变量既然是一个变量就要在内存中占用字节数
    指针变量在内存中占据多少字节数？无论指针是什么类型在内存中都是占据8个字节。那为什么指针还要分类呢？
    p指针变量中存储的是num变量的地址，也就是num变量低字节的地址，通过p指针只能找到这个地址的字节，这个时候，通过p指针找到这个字节，操作的时候，操作多少个字节是根据指针的类型来决定的。
    指针变量的类型决定了通过这个指针找到字节以后，连续操作多少个字节空间。
    int 指针 连续操作4
    double 连续操作8
    float  连续操作4
    char  连续操作1
    所以，指针的类型如果不和指向的变量的类型相同的话，那么通过指针就无法正确的操作指向的变量，所以，指针的变量一定要指向一个和自己类型相同的普通变量才可以
14. 多级指针
    一个指针变量中存储的是一个一级指针的地址，他就是二级指针，三级指针以此类推
    二级指针：数据类型 ** 指针名
    二级指针只能存储一级指针变量的地址。
    二级指针的使用： 使用指针的时候，有几颗*就多拐几个弯。
    只要自己细心分析一定可以分析出来。
15. 指针与整数的加减法
    指针可以和整数进行加减运算，指针+1并不是在指针地址的基础之上加一个字节的地址，而是在这个指针地址的基础之上加一个单位变量占用的字节数，如果指针类型是int * 则+1代表加4个字节地址，以此类推
16. 指针与数组
    1). 使用指针遍历数组的第一种方式.
         int arr[7] = {10,20,30,40,50,60,70};
         int* p1 = arr;//p1指针指向了数组的第0个元素.
         
         for(int i = 0; i < 7; i++)
         {
            printf("%d\n",*(p1+i));
         }
 
     2). 使用指针遍历数组的第二种方式.
         
         int arr[7] = {10,20,30,40,50,60,70};
         
         for(int i = 0; i < 7; i++)
         {
            printf("%d\n",*(arr+i));
         }
         
     3). 使用指针遍历数组的第三种方式.
 
         int arr[7] = {10,20,30,40,50,60,70};
         int* p1 = arr;
         
         for(int i = 0; i < 7; i++)
         {
            printf("%d\n",*(p1++));
         }
 
         注意的地方,每次循环.p1的值都会变化.
         最后1次执行完毕之后. p1指针指向外面去了.
         p1就不再执行数组中的任何元素了.
    注意: 数组名代表数组的地址.而数组一旦创建.数组的地址就确定了.不能改变
    所以.我们不能为数组名赋值. 不能修改数组名的值. 但是可以使用数组名的值.
17. 数组作为函数的参数的本质
    当数组作为函数的参数的时候，在声明这个参数数组的时候，他并不是去创建一个数组，而是去创建一个用来存储地址的指针变量，如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组变成了指针，
    左移，在声明参数的时候不是创建数组，而是创建一个存储数组地址的指针变量，这也就是为什么我们通过sizeof计算参数数组得到的永远都是8.所以以后我们的函数如果带了一个参数，这个参数是一个数组，建议直接写一个指向数组的第0个元素的指针，在传入长度
18. 索引的本质
    指针变量后面可以使用中括弧，在中括弧中写上下标来访问数据。
    p[n];前提p是一个指针变量
    完全等价于 *（p + n）;
    操作数组我们虽然使用中括弧下标来操作，实际上内部仍然使用的指针来操作
19. 存储指针的数组
    如果一个数组是用来存储指针类型的数据的话，那么这个数据就叫做存储指针的数组
    格式 元素类型 数组名[数组长度];
    int *  arr[3];
    arr数组里面可以存储int指针数据，最多存储3个
20. 指针与指针之间的减法运算
    指针与指针之间可以做减法运算，结果是一个long类型的数据，
    结果的意义代表两个指针指向的变量之间相差多少个单位变量，绝大多数情况下，我们用在判断数组的两个元素之间相差多少个元素
    如果参与减法运算的两个指针不指向同一个数组，结果就有问题
    结果 = 两个指针的差 / 每一个指针变量对应的普通变量占用的字节数。
    只能做减法运算
21. 指针与指针在之间的比较运算
    可以判断两个指针指向的变量的字节，谁在高字节，谁在低字节。
    两个指针的地址是不是同一个地址。
22. 指针和字符变量
    chaar *name = "jack";
    直接将一个字符串数据初始化给一个字符指针
    字符指针存储和字符数组存储的区别
    1. 当他们都是局部变量的时候，字符数组是申请在栈区的，字符串的每一个字符存储在字符数组的每一个元素中。指针变量是声明在栈区的。此时字符串数据是以字符数组的形式存储在常量区的。此时指针变量中存储的是字符串在常量去的地址
    2. 当他们作为全局变量的时候，字符数组是存储在常量区的，字符串的每一个字符是存储在这个数组中的每一个元素中。字符指针也是存储在常量去，字符串也是以字符数组的形式存储在常量区，指针中存储的是字符串在常量区的地址。
    以字符数组存储的字符串数据，可以修改字符数组的元素。可变
    以字符指针的形式存储字符串数据，这个时候字符指针指向的字符串数据是无法修改的，不可变
    字符串的恒定型
    前提：以字符指针形式存储的字符串
    1. 当我们以字符指针的形式存储字符串的时候，无论如何，字符串数据是存储在常量区的，并且，一旦存储到常量去中去，这个字符串数据就无法更改。
    2. 当我们以腐殖质真的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储到常量区中。
    3. 当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，而是重新的创建了一个字符串，把这个新的字符串的地址赋给他。
    4. 最容易混淆
       char *name = "jack";
       nsme = "rose";这样可以 但是不是吧jack改成了rose，而是重新创建了一个"rose",把rose地址赋值给name
    建议使用字符指针来存储字符串数据。优势：长度任意。
    
    
23. 内存中的五大区域
    内存当中分为五大区域
    1. 栈 - 专门用来存储局变量，所有的局部变量都是声明在栈区域当中
    2. 堆 - 允许程序员手动的从堆申请空间来使用。程序员自己申请指定字节数的空间。
    3. BSS段 - 用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个变量是没有初始化的，存储在BSS段，初始化之后，全局变量就会被放到常量区。
    4. 数据段/常量区 - 用来存储已经初始化的全局变量、静态变量，还有常量数据
    5. 代码段 - 用来存储程序的代码/指令
    为什么要分区个区域，不符按哪一个区域都是用来存储数据的，不同的数据存储在不同的区域，方便系统的管理
24. 面试题讲解
    求一个字符串中"e"出现的次数
    遍历每一个字符，判断这个字符如果是e 计数器++
    通过指针找到字符串的第一个字符，不断+1找下一个字符，知道‘\0’结束。
25. 字符串数组
    char *names[4] = {"","","",""};
    names数组的元素的类型是char指针，初始化给元素的字符串数据是存储在常量区的。元素中存储的是字符串在常量区的地址
    存储指针的数组，每一个元素的类型是一个指针，指针占得内存为8个字节。
26. fputs()函数
    1. fputs();  f --> File
    作用: 将字符串数据 输出到 指定的流中.
         流: 标准输出流->控制台.
             文件流 --> 磁盘上的文件.
    使用格式:
    fputs(要输出的字符串,指定的流);
    1). 要使用fputs函数将字符串数据输出到标准输出流.
        标准输出流: 控制台. stdout
    2). 将字符串存储到文件中.
        a. 要先声明1个文件指针.指向磁盘上的文件.
           fopen函数可以创建1个指向文件的指针. 
           fopen函数的两个参数:
           第1个参数: 文件的路径,代表创建的指针就指向这个文件.
           第2个参数: 操作文件的模式. 你要对这个文件做什么操作.必须要告诉他.
                    "w"  --> write  代表你要向这个文件写入内容.
                    "r"  --> read   代表你从这个文件中读取数据.
                    "a"  --> apped  追加 代表你向这个文件中追加数据
                    
           当操作模式是"w"的时候,如果文件不存在. 就会创建这个文件.
                              如果文件存在. 就会将原来的文件替换掉.
 
           当操作模式是"a"的时候.如果文件存在,则追加.如果不存在就创建这个文件.
        b. 使用fputs函数将字符串写入到指定的文件流中.
            fputs(字符串,文件指针);
        c. 写完之后,一定要记得使用fclose()函数 将这个文件关闭.
        
27. fget()函数
    作用: 从指定的流中读取字符串.
         这个流可以是我们的标准输入流-->控制台.
             也可以是我们的文件流.
    1). 使用fgets函数从标准输入流中读取数据.
        使用fgets函数从控制台接收用户输入字符串.
        前面学习的scanf函数gets函数也可以实现这个功能.
        scanf的缺点
        a. 不安全.
        b. 输入的空格会被认为结束.
        gets函数的缺点.
        a. 不安全.
        fgets函数的优点
        a. 安全
        b. 空格也会一并接收.
        语法:  fgets(要将字符串存储到哪1个数组中,最多接收多少个长度的字符串,指定流);
        第2个参数: 我们写1个n 那么函数最多就接收n-1个长度的字符串.
                  这个参数一般情况下和第1个参数数组的长度一致.
        stdin: 代表标准输入流. 也就是键盘流 控制台输入.
        为什么是安全的?
        a. 如果我们输入的字符串的长度大于等于了 第2个参数n. 只会接收前面的n-1个. 然后最后1个自动是'\0'.
           这样,就不会崩了.
        b. 如果我们输入的字符串的长度刚好等于n-1 那就是最完美的.
        c. 如果我们输入的字符串的长度小于了n-1. 那么就会将我们最后输入的换行字符'\n'一并的接收.
           然后后面才是'\0'结束符.
        解决方案: 输入完毕之后,判断字符数组中存储的字符串最后1个是不是'\n'
                 如果是'\n' 那么就将其替换为'\0'.
    2). 使用fgets函数从文件流中读取数据:
        就是读取磁盘上文件的内容.
         a. 先创建1个文件指针.
             //1. 创建1个读取文件的文件流.
             FILE* pFile = fopen("/Users/Itcast/Desktop/abc.txt", "r");
         b. 准备1个字符数组.准备存储读取到的字符串数据.
             char content[50]; 
        c. 使用fgets函数从指定的文件流中读取.
            fgets(content, 50, pFile);
        d. 读取成功:
            printf("读取的内容是: %s\n",content);
        e. 关闭文件流
            fclose(pFile);  
            
28. const修饰基本数据类型的变量
    1. const是1个关键字.是来修饰我们的变量的.
    也就是说在声明变量的同时,可以使用const关键字来修饰.
    const int num = 10;
    一般情况下来说,被const修饰的变量具备一定程度上的不可变性.
    被const修饰的变量我们叫做只读变量.
    2. const修饰基本数据类型的变量.
    基本数据类型: int、double、float、char.
    1). const int num = 10;
        这个时候.num变量的值只能去取值,而不能去修改.
    2). int const num = 10;
        效果同上.
    3. const修饰数组.
    1). const int arr[4] = {10,20,30,40};
        数组的元素的值不能修改.
    2). int const arr[4] = {10,20,30,40};
        效果同上.
    4. const修饰指针;
    1). const int* p1 = &num;
        无法通过p1指针去修改指针指向的变量的值. 但是如果直接操作变量这是可以的.
        但是指针变量的值可以改.可以把另外1个变量的地址赋值给这个指针.
    2).  int const * p1 = &num;
         效果同上
    3).  int  * const p1 = &num;
         p1的值不能修改,但是可以通过p1去修改p1指向的变量的值.
    4).  int const  * const p1 = &num;
         既不能修改p1的值,也不能通过p1去修改p1指向的变量的值.
    5. const的使用场景.
    1). const的特点:
        被const修饰的变量.是只读变量,只能取值.而不能改值.
        所以,const变量的值,至始至终都不会发生变化.
    2). 当某些数据是固定的,在整个程序运行期间都不会发生变化. 并且你也不允许别人去修改.
        那么这个时候,我们就可以使用const.
        const int  width: 800
        const int  height:600
    3). 当函数的参数是1个指针的时候.这个时候,函数的内部是有可能会修改实参变量的值.
        这个时候
        函数想传递给调用者1个信息: 你放心大胆的传给我吧.我肯定不会修改的.
        那么这个时候,就可以给参数加1个const
        所以.我们以后在调用函数的时候.如果看到了参数被const修饰. 放心大胆的给.
        函数内部只会使用我们的值 绝对改不了我们的值.
29. 指向函数的指针。
 
 1. 我们之前学习的指针.
    一般情况都是指向另外1个变量.
 
    int num = 10;
    int* p1 = &num;
 
 
    指针是指向内存中的1个字节空间的.
 
 
 2. 程序在运行的时候. 会将程序加载到内存.
    程序中主要有代码/指令.
 
    代码段中主要存储程序的代码.而程序的代码就包括函数.
    所以,函数肯定要存在内存的代码段中.
 
    既然函数要存储在内存中 那么肯定要用1块空间来存储.
    那么这个块空间一定有1个地址.n
    那么我们就可以声明1个指针,存储这个函数的地址.让这个指针指向这个函数.
 
    使用指针来间接的调用函数.
 
    优势: 调用函数有了两种方式.
 
    -> 直接使用函数名调用
    -> 使用指向函数的指针间接调用.
 
 
 
 3. 指向函数的指针的声明
 
    1). 1个指针函数的指针.并不是任意的函数都可以指向.
        而是有限定的.要求指向的函数的返回值类型和参数描述必须要与指针的描述一样.
 
    2). 声明语法
    
        返回值类型 (*指针名)([参数列表]);
 
        void (*pFunction)();
 
        表示声明了1个指向函数的指针,名字叫做pFunction.
        这个指针只能指向没有返回值,并且没有参数的函数.
 
 
        int (*pFun)(int num1,int num2);
        表示声明了1个指向函数的指针,名字叫做pFun.
        这个指针只能指向返回值为int类型 并且有两个整型的参数的函数.
 
 
 
 4). 指向函数的指针的初始化.
 
      1). 取到符合指针条件的函数的地址.
 
         函数的名称就代表函数的地址.
 
 
 
     2). 将地址赋值给指针变量.
 
         直接将符合条件的函数的名称赋值给这个指针.
 
 
 
 
    3). 注意.
 
        函数名代表函数的地址.
        不要函数名加小括弧.如果加了小括弧,就代表执行这个函数 拿到这个函数的返回值.
 
 
 
 
 5).如何使用指针来间接的调用指针指向的函数呢?
 
    void (*pFunc)() = test; //pFunc指针就指向了test函数
        
    pFunc();
 
    (*pFunc)();
 
 
    有参数就给, 有返回值就接.
 
 
 
 
 6).小技巧.
 
    如果要定义1个指针指向1个函数
    拷贝这个函数头.删除函数名 用小括弧代替 里面写上* 加指针名称